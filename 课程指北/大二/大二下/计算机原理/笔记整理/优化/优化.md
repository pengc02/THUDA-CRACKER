# 优化

## 1.编译器局限与一般优化规则

分层次实现优化：

算法级、代码级、系统级

### 1.1编译器的局限

编译优化平衡trade-off

* 在基本约束条件下运行：不能引起程序行为的任何改变
* 无法真正理解程序：对程序员来说很明显的行为，可能会因语言和编码风格而变得模糊/混乱
* 深入优化往往降低程序可读性和模块性：程序易出错，难以修改和扩展  

* 大多数分析只在过程范围内进行：在大多数情况下，全程序分析过于昂贵；新版本的GCC在单个文件中进行过程间分析。但是, 不做文件间的代码分析
* 大多数分析都是基于静态信息的：编译器很难预测运行时的输入  



### 1.2 脱离具体编译器和处理器的一般化优化思路  

* 代码移动code motion：

  1. 循环内计算结果相同的代码移动到循环外部

  2. 函数调用不能随便移动，因为不知道有没有副作用

* 减少过程调用(Reduction in Procedure Calling)  
  1. inline函数声明点在调用点之前

* 复杂运算简化
  1. 移位替代乘法
  2. 加法代替乘法

* 共享公用子表达式
* 消除内存别名(Remove memory aliases)  
  1. 内存别名：对于相同内存的多个不同名引用（两个指针变量指向相同实体）  
  2. 编译器不知道：函数调用何时发生，实参是否使用了内存别名（因为可能存在地址
     运算，无法通过静态分析预知）  
  3. 应对方法1：中间结果不要访问潜在的内存别名  
  4. 应对方法2（仅限于C99及更高，不适用于C++）：告诉编译器不要考虑内存别名  ：关键字restrict：该关键字可以用于修饰指针，以表示指针指向内存之间不存在相互覆盖  。

## 2.性能评价与测试



评价程序性能的常数因子









